package org.glowa.danube.components.actor.touristmodel;


import java.io.FileWriter;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Map.Entry;

import org.glowa.danube.components.actor.interfaces.ModelControllerToRekurTouristModel;
import org.glowa.danube.components.actor.interfaces.RekurTouristModelToModelController;
import org.glowa.danube.components.actor.utilities.ClimateData;
import org.glowa.danube.components.actor.utilities.IntegerArray2D;
import org.glowa.danube.deepactors.actors.actor.Actor;
import org.glowa.danube.deepactors.model.AbstractActorModel;
//import org.glowa.danube.utilities.time.DanubiaCalendar;
//import org.glowa.danube.utilities.visualization.LocalVisualization;
import org.glowa.danube.utilities.internal.DanubiaLogger;

/**
 * The class <tt>TouristModel</tt> is the mainclass of the subcomponent Tourist Model of component deepactor .
 * 
 * Configurationfile can be found unter metadata/components/touristmodel.cfg
 * 
 * @author Dennis Joswig
 */



public class TouristModel extends AbstractActorModel<TouristProxel> implements RekurTouristModelToModelController
{
  static final long serialVersionUID = 1;
  /**
   * holds the URL for the Databaseconnection generated by the attributes given in the config-file.
   * Configurationfile can be found unter metadata/components/touristmodel.cfg
   */
  private String database = "jdbc:mysql://localhost/rekur?user=root&password=bla";
  /**
   * holds the database name given in the configfile.
   * Configurationfile can be found unter metadata/components/touristmodel.cfg
   */
  private String dataBaseName;
  /**
   * holds the user nme for the the database connection. Can be set up in the config-file.
   * Configurationfile can be found unter metadata/components/touristmodel.cfg
   */
  private String userName;
  /**
   * holds the database password given in the config-file.
   * Configurationfile can be found unter metadata/components/touristmodel.cfg
   */
  private String password;
  /**
   * holds the name of the ralation containing the sourcearea attributes. Given in the config-file.
   * Configurationfile can be found unter metadata/components/touristmodel.cfg
   */
  private String sourceareaTable = "sourceareaoverview";
  /**
   *  holds the name of the ralation containing the sourcearea demography-attributes. Given in the config-file.
   *  Configurationfile can be found unter metadata/components/touristmodel.cfg
   */
  private String demoTable = "demography";
  /**
   * holds the name of the ralation containing the sourcearea ids. Given in the config-file.
   *  Configurationfile can be found unter metadata/components/touristmodel.cfg
   */
  private String landkreisIDtoSourceAreaIDTable = "landkreise";
  //private HashMap<Integer,Integer[][]> numberOfTourists;
  public HashMap<Integer,DATA_Destination> destinations = new HashMap<Integer, DATA_Destination>();
  public ModelControllerToRekurTouristModel controller; 
  private boolean destinationInit = true;
  private int weeksToForecast =52;
  public int priceCategories = 7;
  private int startYear;
  private int startMonth;
  private int startDay;
  public GregorianCalendar currentDate;
  public int preSimulationTime ;
  public boolean preSimulation = true;
  
  private boolean logging = true;
  private static DanubiaLogger logger = DanubiaLogger.getDanubiaLogger(TouristModel.class);
  
  
	/* (non-Javadoc)
	 * @see org.glowa.danube.deepactors.model.AbstractActorModel#init()
	 */
	protected void init() {
		
		System.out.println("TouristInit");
		startYear = simulationTime().getYear();
		startMonth = simulationTime().getMonth();
		startDay = simulationTime().getDay();
		
		try
	    {preSimulationTime = Integer.parseInt(this.componentConfig().getComponentProperties().getProperty("preSimulationTime"));}
	    catch (NumberFormatException nfe)
		   {if (logging) 
		   		{logger.warn("******NumberFormatException perSimTime!!");
		   		preSimulationTime = 0;
		   		}//if
		   }//Catch
	   
	    if(preSimulationTime == 0){
			preSimulation = false;
		}
	    

	    dataBaseName = this.componentConfig().getComponentProperties().getProperty("dataBaseName");
	    userName = this.componentConfig().getComponentProperties().getProperty("userName");
	    password = this.componentConfig().getComponentProperties().getProperty("password");
	    database = "jdbc:mysql://localhost/"+dataBaseName+"?user="+userName+"&password="+password;
	    sourceareaTable = this.componentConfig().getComponentProperties().getProperty("sourceareaTable");
	    demoTable = this.componentConfig().getComponentProperties().getProperty("demoTable");
	    landkreisIDtoSourceAreaIDTable = this.componentConfig().getComponentProperties().getProperty("landkreisIDtoSourceAreaIDTable");
	    
	    
		initSourceAreasFromDataBase();
		updateDemography(startYear);
		initTourists();
		writemap();
		
		try {
			controller = (ModelControllerToRekurTouristModel) getImport("org.glowa.danube.components.actor.interfaces.ModelControllerToRekurTouristModel");
		} catch (Exception ex) {
			this.logger().warn(ex);
		}
	}
	
	/**
	 * Reads the additional Attributes of the sourceAreas from the database
	 */
	private void initSourceAreasFromDataBase(){
		try {
            // Der Aufruf von newInstance() ist ein Workaround
	        // für einige misslungene Java-Implementierungen
		
			Class.forName("com.mysql.jdbc.Driver").newInstance();
			Connection con = DriverManager.getConnection(database);
			Statement stmt = con.createStatement();
			
			String query = " select * from "+sourceareaTable+
					" natural join "+landkreisIDtoSourceAreaIDTable+";";
			
			ResultSet sa = stmt. executeQuery(query);
			int i = 1;
			while(sa.next()&&i<=actorMap().size()){
//				System.out.println(sa.getString(1)+sa.getString(2)+sa.getString(3)+sa.getString(4)+sa.getString(5));
				DA_SourceArea currentActor =(DA_SourceArea)(actorMap().getEntry(Integer.parseInt(sa.getString("RekurID"))));
				currentActor.name = sa.getString(2);
				try{
					currentActor.size = Float.parseFloat(sa.getString(3));
				}
				catch(Exception e){
					currentActor.size = 0.0f;
					e.printStackTrace();
				}
				try{
					if(!sa.getString(4).equals("-"))currentActor.buyingPower = Float.parseFloat(sa.getString(4));
				}	
				catch(Exception e){
					currentActor.buyingPower = 0.0f;
					e.printStackTrace();
				}
				i++;
				//System.out.println(sa.getString("RekurID"));
			}	
		} catch (Exception ex) {
            // Fehler behandeln
			ex.printStackTrace();
		}
	}
	
	
	public void updateDemography(int year){
		try {
			Class.forName("com.mysql.jdbc.Driver").newInstance();
			Connection con = DriverManager.getConnection(database);
			Statement stmt = con.createStatement();
			String yearString;
			
			yearString = (""+year).substring(2);

			String query = " select * from "+landkreisIDtoSourceAreaIDTable+
					" natural join (select * from "+demoTable+" where year = '"+yearString+"')as demo;";
			
			ResultSet sa = stmt. executeQuery(query);
			int i = 1;
			while(sa.next()&&i<=actorMap().size()){
//				System.out.println(sa.getString(1)+sa.getString(2)+sa.getString(3)+sa.getString(4)+sa.getString(5));
				DA_SourceArea currentActor =(DA_SourceArea)(actorMap().getEntry(Integer.parseInt(sa.getString("RekurID"))));
				for(int z = 0;z<10;z++){
					try{	
						currentActor.demography[z] = Float.parseFloat(sa.getString(z+4));
					}
					catch(Exception e){
						currentActor.demography[z] = 0;
						e.printStackTrace();
					}
				}
				
				try{
					currentActor.numberOfCitizens = Float.parseFloat(sa.getString(14));
				}
				catch(Exception e){
					currentActor.numberOfCitizens = 0;
					e.printStackTrace();
				}
				
				i++;
//				System.out.println(sa.getString("RekurID"));
				//con.close();
			}	
		} catch (Exception ex) {
	        // Fehler behandeln
			ex.printStackTrace();
			System.out.println("Error");
		}
	}
	
	/**
	 * This Method initializes all Tourist Agents.
	 */
	private void initTourists(){
		for(DA_SourceArea sa : actorMap().getEntries(DA_SourceArea.class).getEntries()){
			int touristCount = 10000;
			if(sa.numberOfCitizens!=0.0f){
				touristCount = (int)(sa.numberOfCitizens*100);
			}
			sa.tourists = new DA_Tourist[touristCount];
			for(int i = 0; i<touristCount; i++){
				sa.tourists[i] = new DA_Tourist(this,sa);
			}
		}
	}
	
	private void writemap(){
		FileWriter writeOut;
		String outputName = "sourcearea.asc";
		try{
			writeOut = new FileWriter(outputName, false);
			writeOut.write("");
			writeOut.flush();
			writeOut = new FileWriter(outputName, true);
			
			
			writeOut.write("ncols 	590\n" +
					"nrows 		258\n" +
					"xllcorner     -2868800\n" +
					"yllcorner     200792\n" +
					"cellsize      10000\n" +
					"NODATA_value  1\n");
			
			try{
				for(int i=1;i<(590*258);i++){
					
					boolean inside = proxel(i).isInside();
					if(inside){
						int found = -1;
						for(Actor entry :actorMap().getEntries()){
							for(int id : entry.getLocation().getPIDArray()){
								if(id == i){
									found = entry.getId();
								}
							}
						}
						if(found!=-1){
							writeOut.write(" "+found);
						}
						else{
							writeOut.write(" "+0);
						}
					}
					else{
						writeOut.write(" "+"1");
					}
					if(i%590==0){
						writeOut.write("\n");
					}
				}
			}
			catch(Exception e){
				writeOut.write(e.getMessage());
			}	
			
			writeOut.flush();
			writeOut.close();
			
			
		}
		catch(Exception e){
			System.out.println(e);
		}
	}
	
	
	public void setDestinationChanged(DA_Tourist tourist){
		for(int[] row:tourist.holidayDestination){
			//numberOfTourists[row[0]][row[1]][row[2]]++;
			//destinations.get(row[0]).numberOfTourists[row[1]][row[2]]++;
			if(destinations.get(row[0]).CurrentNumberOfTourists.containsKey(tourist.origin)){
				destinations.get(row[0]).CurrentNumberOfTourists.get(tourist.origin).array[row[1]][row[2]]++;
			}
			else{
				destinations.get(row[0]).CurrentNumberOfTourists.put(tourist.origin, new IntegerArray2D(weeksToForecast, priceCategories));
				destinations.get(row[0]).CurrentNumberOfTourists.get(tourist.origin).array[row[1]][row[2]]++;
			}
		}
	}
	
	/* (non-Javadoc)
	 * @see org.glowa.danube.deepactors.model.AbstractActorModel#getData()
	 */
	public void getData() {
		if(destinationInit){
			int i = 0;
			for(Entry<Integer, boolean[]> entry:controller.getHolidayTypes().entrySet()){
				DATA_Destination currentDest = new DATA_Destination();
				currentDest = new DATA_Destination();
				if(entry.getValue()==null){
					System.out.println(entry.getKey()+" Entry.getValue() ist null");
				}
				
				
				currentDest.holidayTypes = entry.getValue();
				currentDest.id = (int)entry.getKey();
				currentDest.country = controller.getCountryIDs().get(entry.getKey());
				destinations.put(entry.getKey(), currentDest);
				i++;
				//System.out.println(text);
			}
			destinationInit = false;
		}
		for(Entry<Integer, ClimateData> dailyClimate: controller.getDailyClimateData().entrySet()){
			destinations.get(dailyClimate.getKey()).updateDailyClimate(dailyClimate.getValue());
			
			if(simulationTime().getDay()==2){
				destinations.get(dailyClimate.getKey()).updateMonthlyClimate(simulationTime().getYear(), simulationTime().getMonth(), controller.getLastMonthClimateData().get(dailyClimate.getKey()));
			}
		}
		
		if(preSimulation && startDay == simulationTime().getDay() && startMonth == simulationTime().getMonth() && startYear == simulationTime().getYear()+preSimulationTime){
			preSimulation = false;
		}
	}

	/* (non-Javadoc)
	 * @see org.glowa.danube.deepactors.model.AbstractActorModel#preCompute()
	 */
	protected void preCompute() {
		 int month = this.simulationTime().getMonth();
		 int year = this.simulationTime().getYear();
		 int day = this.simulationTime().getDay();
		 if(month == 1 && day == 1){
			 //System.out.println(""+ day+" "+month+" "+year);
			 updateDemography(year);
		 }
		 currentDate = new GregorianCalendar(year, month-1, day-1);
		 currentDate.setMinimalDaysInFirstWeek(4);
		 currentDate.setFirstDayOfWeek(1);
		 //System.out.println("Woche "+currentDate.get(GregorianCalendar.WEEK_OF_YEAR)+" Jahr "+currentDate.get(GregorianCalendar.YEAR));
		 //System.out.println(""+year+" "+month+" "+day);
		 
	}
	
	/* (non-Javadoc)
	 * @see org.glowa.danube.deepactors.model.AbstractActorModel#postCompute()
	 */
	protected void postCompute(){
		 // Durchfuehrung alle monatlichen Berechnungen zum 1. des Monats!
//		 int monat = this.simulationTime().getMonth();
//		 int jahr = this.simulationTime().getYear();
//		 int tag = this.simulationTime().getDay();
//		 Alle Destination durchlaufen und nach Engpässen checken, um ggf. neue Entscheidung anzustoßen.
		boolean notOutOfCapacity = true;
		while(notOutOfCapacity){
			boolean reDecided = false;
			for(Entry<Integer, DATA_Destination> destination : destinations.entrySet()){
				if(destination.getValue().checkNumberOfTourists()){
					reDecided = true;
				}
			}
			notOutOfCapacity = reDecided;
		}
	}
	
	/* (non-Javadoc)
	 * @see org.glowa.danube.deepactors.model.AbstractActorModel#commit()
	 */
	public void commit()
	{
		if(destinations !=null){
			for(Entry<Integer, DATA_Destination> dests:destinations.entrySet()){
				
				for(Entry<DA_SourceArea, IntegerArray2D> sources: dests.getValue().CurrentNumberOfTourists.entrySet()){
					int week = 0;
					for(int[] z :sources.getValue().array){
						int category = 0;
						for(int v:z){
							if(v!=0)System.out.println("DestinationID: "+dests.getKey()+" SourceArea: "+sources.getKey().getId()+" "+sources.getKey().name+" Category: "+category+" Week: "+week+" Number: "+v);
							category++;
						}
						week++;
					}
				}
				dests.getValue().numberOfTouristsLastDate = dests.getValue().CurrentNumberOfTourists;
				dests.getValue().CurrentNumberOfTourists = new HashMap<DA_SourceArea, IntegerArray2D>();
			}
		}
	}
	
	
	/* (non-Javadoc)
	 * @see org.glowa.danube.deepactors.model.AbstractActorModel#store()
	 */
	protected void store()
	{
//		DanubiaCalendar writeOutTime = simulationTime();
	}//Store
	
	/**
	 * Inits the gmt: Societal scenario and Actions will be initialized.
	 */
	protected void initGMT()
	{
		// Gesellschaftliche Megatrends
		/*int gmt;
	    //try
	    gmt = Integer.parseInt(this.componentConfig().getComponentProperties().getProperty("gmt"));
	    */
	}
	@Override
	public int[][][] getNumberOfTourists() {
		// TODO Auto-generated method stub
		//return numberOfTourists;
		return null;
	}
	  
}//.java





