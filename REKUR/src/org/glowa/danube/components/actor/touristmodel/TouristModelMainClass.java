package org.glowa.danube.components.actor.touristmodel;


import java.io.FileWriter;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Vector;
import java.util.Map.Entry;

import org.glowa.danube.components.actor.interfaces.ModelControllerToRekurTouristModel;
import org.glowa.danube.components.actor.interfaces.RekurTouristModelToModelController;
import org.glowa.danube.components.actor.utilities.ClimateData;
import org.glowa.danube.components.actor.utilities.Holidays;
import org.glowa.danube.deepactors.actors.actor.Actor;
import org.glowa.danube.deepactors.model.AbstractActorModel;
import org.glowa.danube.tables.FloatDataTable;
import org.glowa.danube.tables.IntegerDataTable;
import org.glowa.danube.tables.MassPerAreaTable;
import org.glowa.danube.tables.TemperatureTable;
import org.glowa.danube.utilities.execution.GetDataEngine;
import org.glowa.danube.utilities.execution.ProvideTask;
import org.glowa.danube.utilities.internal.DanubiaLogger;
import org.glowa.danube.utilities.time.DanubiaCalendar;

import com.mysql.jdbc.DatabaseMetaData;

/**
 * The class <tt>TouristModel</tt> is the mainclass of the subcomponent Tourist Model of component deepactor .
 * 
 * Configurationfile can be found unter metadata/components/touristmodel.cfg.
 * 
 * @author Dennis Joswig
 */



public class TouristModelMainClass extends AbstractActorModel<TouristProxel> implements RekurTouristModelToModelController
{
	/**
	 * Saves the scenario used in this run.
	 */
	public int touristscenario; 
	/**
	 * Saves the current run number.
	 */
	public int number;
	/**
	 * Saves the scenario used in this run.
	 */
	public static String climatescenario;
	
	static final long serialVersionUID = 1;
	/**
	 * holds the URL for the Database connection generated by the attributes given in the config-file.
	 * Configuration file can be found under metadata/components/touristmodel.cfg
	 */
	private String database = "jdbc:mysql://localhost/rekur?user=root&password=bla";
	/**
	 * holds the database name given in the configfile.
	 * Configuration file can be found under metadata/components/touristmodel.cfg
	 */
	private String dataBaseName;
	/**
	 * holds the user name for the the database connection. Can be set up in the config-file.
	 * Configuration file can be found unter metadata/components/touristmodel.cfg
	 */
	private String userName;
	/**
	 * holds the database password given in the config-file.
	 * Configuration file can be found under metadata/components/touristmodel.cfg
	 */
	private String password;
	/**
	 * holds the name of the relation containing the sourcearea attributes. Given in the config-file.
	 * Configuration file can be found under metadata/components/touristmodel.cfg
	 */
	private String sourceareaTable = "sourceareaoverview";
	/**
	 * holds the name of the relation containing the sourcearea ids. Given in the config-file.
	 *  Configuration file can be found under metadata/components/touristmodel.cfg
	 */
	private String landkreisIDtoSourceAreaIDTable = "landkreise";
	/**
	 * holds the name of the relation containing the touristTypes. Given in the config-file.
	 *  Configuration file can be found under metadata/components/touristmodel.cfg
	 */
	private String touristTypesTable = "touristTypes";
	/**
	 * holds the name of the relation containing the distances. Given in the config-file.
	 *  Configuration file can be found under metadata/components/touristmodel.cfg
	 */
	private String distance = "distance";
	/**
	 * holds the name of the relation containing the buyingpower. Given in the config-file.
	 *  Configuration file can be found under metadata/components/touristmodel.cfg
	 */
	private String buyingpower = "kaufkraft";
	/**
	 * HashMap with destination-Ids and their DATA-Objects.
	 */
	private HashMap<Integer,DATA_Destination> destinations = new HashMap<Integer, DATA_Destination>();
	
	/**
	 * HashMap with destination-Ids and their DATA-Objects of all active Destiantions.
	 */
	public HashMap<Integer,DATA_Destination> activedests = new HashMap<Integer, DATA_Destination>();
	
	/**
	 * This HashMap contains all touristTypes.
	 */
  	public HashMap<Integer, DA_AbstractTouristType> touristTypes = new HashMap<Integer, DA_AbstractTouristType>();
  	
  	/**
  	 * Saves the name for the relation containing the spreading for districts less than 50000 inhabitants.
  	 */
  	public String lessThan50000;
  	/**
  	 * Saves the name for the relation containing the spreading for districts more than 50000 inhabitants.
  	 */
  	public String moreThan50000;
  	
  	/**
  	 * This HashMap contains the spreading for each tourist type <TypeId,Int[less or more than 50000][spreading]>.
  	 */
  	public HashMap<Integer, Integer[][]> typeSpreading = new HashMap<Integer, Integer[][]>();
  	
  	/**
  	 * This array saves the touristtypes age structure.
  	 */
  	
  	public int[] agestruct = {0,20,30,40,50,60,70};
  	
  	/**
  	 * Reference to the import controller. 
  	 */
  	public ModelControllerToRekurTouristModel controller; 
  	/**
   	* Checks the initialization. 
   	*/
  	private boolean destinationInit = true;  
  	/**
   	* Saves the number of price categories.
   	*/
  	public int priceCategories = 7;
  	/**
   	* Saves the simulation start year.
   	*/
  	public int startYear;
  	/**
   	* Saves the simulation start month.
   	*/
  	public int startMonth;
  	/**
   	* Saves the simulation start day.
   	*/
  	public int startDay;
  	/**
   	* Saves the last week that has been written into the output database.
   	*/
  	private int printedWeek = 0;
  	/**
   	* Saves the current simulationdate as GregorianCalendar-Object to get the weekOfYear.
   	*/
  	public GregorianCalendar currentDate;
  	/**
   	* Number of years of the pre simulation time.
   	*/
  	public int preSimulationTime;
  	/**
   	* Indicates if the presimulation is finished.
   	*/
  	public boolean preSimulation = true;
  	/**
   	* logging.
   	*/
  	private boolean logging = true;
  	/**
   	* reference to the danubialogger.
   	*/
  	private static DanubiaLogger logger = DanubiaLogger.getDanubiaLogger(TouristModelMainClass.class);
//  	/**
//   	* Saves the number of tourists to export to the DestiantionModel-Object.  HashMap<DestinationID, HashMap<year, HashMap<week, HashMap<category, HashMap<sourceareaID, quantity>>>>>
//   	*/
//  	private HashMap<Integer, HashMap<Integer, HashMap<Integer, HashMap<Integer, HashMap<Integer, Integer>>>>> touristPerDest = new HashMap<Integer, HashMap<Integer,HashMap<Integer,HashMap<Integer,HashMap<Integer,Integer>>>>>();
  	
  	
  	/**
   	* Saves the number of tourists to export to the DestiantionModel-Object.  HashMap<DestinationID, HashMap<year, HashMap<week, HashMap<category, HashMap<sourceareaID, HashMap<Type, HashMap<age, HashMap<sex,quantity/arrivals[]>>>>>>>>
   	*/
  	private HashMap<Integer, HashMap<Integer, HashMap<Integer, HashMap<Integer, HashMap<Integer, HashMap<Integer, HashMap<Integer, HashMap<Integer, Integer[]>>>>>>>> touristPerDest = new HashMap<Integer, HashMap<Integer,HashMap<Integer,HashMap<Integer,HashMap<Integer,HashMap<Integer,HashMap<Integer,HashMap<Integer,Integer[]>>>>>>>>();
  	
  	
  	
  	
  	
  	/**
   	* Sets if a touristHas booked;
   	* 
   	*/
  	private boolean booked = false;
  	/**
   	* Statement-Object for the database connection.
   	*/
  	private Statement stmt = null;
  
  	/**
   	* Holds the relation names for the tourists per destinations output relations.
   	*/
  	private String touristsPerDestinationTables;
  
  	/**
   	* Saves if the redecide process needs to be executed.
   	*/
  	private boolean redecide = true;
//  	public boolean compute = true;
  	
  	/**
	 * Specifies if the simulation is run in debug mode.
	 */
	public boolean debug = true;
	
	/**
	 * Specifies if the buyingpower age-categories names.
	 */
	public int[] buyingpowercatbuttom = {15,25,35,45,55,65,15};//{"kk15_24","kk25_34","kk35_44","kk45_54","kk55_64","kk65_130","kk15_103"};
	/**
	 * Specifies if the buyingpower age-categories names.
	 */
	public int[] buyingpowercattop = {24,34,44,54,64,130,130};
	/**
	 * Contains all switched off countries.
	 */
	public HashMap<Integer, Integer> switchOffCountries = new HashMap<Integer, Integer>();
	Connection con = null;
	
	private boolean firstday = true;
	
	private boolean firstmonth = true;
	
	private boolean firsttable = true;
	
	
	/**
	 * Saves the different holiday type probabilities for each life phase, age and separated between cities and rural areas.
	 * [life phase][rural = 0,city = 1][age classes][holidayType]
	 */
	public float[][][][] LP_Probabilities= new float[7][2][7][9];
	
	/**
	 * Saves the budget per life phase <LP, float[ages][budget]> fixed ages 14-19, 20-29... 70+ and variable budget.
	 */
	public HashMap<Integer, float[][]> lpBudget = new HashMap<Integer, float[][]>();
	
	
	/**
	 * Saves the distance matrix HashMap<0=SH 1=NB 2=SB HashMap<DestID, Distance in m>>.
	 */
	public HashMap<Integer, HashMap<Integer, Integer>> distanceMatrix = new HashMap<Integer, HashMap<Integer, Integer>>();
	
	/**
	 * Saves the subsidiary costs per country.
	 */
	public HashMap<Integer,Integer> nklaender = new HashMap<Integer, Integer>();
	
	/**
	 * Saves the distance rates per life phase. double[lifephase][0 = <500; 1 = 500-1000; 2 >1000];
	 */
	public double[][] LPentfernungen = new double[7][3];
	
	/**
	 * Saves the price per km int euro of  three transport systems [0=car, 1=plane, 2=train/bus];
	 */
	public int[] priceperkm = new int[3];
	
	
	/**
	 * Saves the different temperature limits per life phase and holiday type <LP ,<holidaytype,[min/max]>>.
	 */
	public HashMap<Integer, HashMap<Integer, Integer[]>> tempLimits = new HashMap<Integer, HashMap<Integer, Integer[]>>();
	
	/**
	 * Saves the relative capacity for each destination <destID,rel capacity>
	 */
	public HashMap<Integer, Integer> relCapacity = new HashMap<Integer, Integer>();
	
	/**
	 * Saves the seasonality for each holidaytype
	 */
	public HashMap<Integer, double[]> htSeason = new HashMap<Integer, double[]>();
	
	/* (non-Javadoc)
	 * @see org.glowa.danube.deepactors.model.AbstractActorModel#init()
	 */
	protected void init() {
		
		System.out.println("TouristInit");
		startYear = simulationTime().getYear();
		startMonth = simulationTime().getMonth();
		startDay = simulationTime().getDay();
		updateCurrentDate();
		preSimulationTime = Integer.parseInt(this.componentConfig().getComponentProperties().getProperty("preSimulationTime"));
		dataBaseName = this.componentConfig().getComponentProperties().getProperty("dataBaseName");
	    userName = this.componentConfig().getComponentProperties().getProperty("userName");
	    password = this.componentConfig().getComponentProperties().getProperty("password");
	    database = "jdbc:mysql://localhost/"+dataBaseName+"?user="+userName+"&password="+password;
	    sourceareaTable = this.componentConfig().getComponentProperties().getProperty("sourceareaTable");
	    //demoTable = this.componentConfig().getComponentProperties().getProperty("demoTable");
	    landkreisIDtoSourceAreaIDTable = this.componentConfig().getComponentProperties().getProperty("landkreisIDtoSourceAreaIDTable");
	    touristTypesTable = this.componentConfig().getComponentProperties().getProperty("touristTypesTable");
	    touristsPerDestinationTables = this.componentConfig().getComponentProperties().getProperty("touristsPerDestinationTables");
	    distance = this.componentConfig().getComponentProperties().getProperty("distance");
	    buyingpower = this.componentConfig().getComponentProperties().getProperty("kaufkraft");
	    
	    lessThan50000 = this.componentConfig().getComponentProperties().getProperty("VerteilungKleiner50000");
	    moreThan50000 = this.componentConfig().getComponentProperties().getProperty("VerteilungGroesser50000");
	    
	    try{
	    	String[] countries = (this.componentConfig().getComponentProperties().getProperty("countryswitchoff")).split(";");
	    	for(String c:countries){
	    		String[] cAndY = c.split(",");
	    		switchOffCountries.put(Integer.parseInt(cAndY[0]), Integer.parseInt(cAndY[1]));
	    		System.out.println(Integer.parseInt(cAndY[0])+ " " +switchOffCountries.get(Integer.parseInt(cAndY[0])));
	    	}
	    }
	    catch(Exception e){
	    	
	    }
	    
	    for(int i = 0; i<7;i++){
	    	for(int z = 0;z<2;z++){
	    		if(z==0){
	    			readLP(i, "Land");
	    		}
	    		else{
	    			readLP(i, "Stadt");
	    		}
	    	}
	    	readLPBudget(i+1);
	    }
	    //checkLP();
//	    checkLPBudget();
	    touristscenario = Integer.parseInt(this.componentConfig().getComponentProperties().getProperty("touristscenario"));
	    climatescenario = this.componentConfig().getComponentProperties().getProperty("climatescenario");
	    Holidays.scenario = Integer.parseInt(this.componentConfig().getComponentProperties().getProperty("holidayscenario"));
	    if(this.componentConfig().getComponentProperties().getProperty("debug").equals("false"))debug = false;
		initSourceAreasFromDataBase();
		
		initTouristTypes();
		readSpreading();
		//checkSpreading();
		
		updateDemography(startYear);
		initTourists();
		readDistancematrix();
		readNKLaender();
		readLPEntfernungen();
		readPricePerKM();
		readTempLimits();
		readRelCapacity();
		readHTSeason();
		if(debug)writemap();
		
		try {
			controller = (ModelControllerToRekurTouristModel) getImport("org.glowa.danube.components.actor.interfaces.ModelControllerToRekurTouristModel");
		} catch (Exception ex) {
			this.logger().warn(ex);
		}
	}
	
	
	/**
	 * Reads one LP.
	 * @param LP number of LP (0-6)
	 * @param cityStatus "Land" oder "Stadt"
	 */
	private void readLP(int LP,String cityStatus){
		try{
			Class.forName("com.mysql.jdbc.Driver").newInstance();
			Connection con = DriverManager.getConnection(database);
			Statement stmt = con.createStatement();
			
			String query = " select * from Lp"+(LP+1)+"_"+cityStatus+";";
			
			ResultSet sa = stmt. executeQuery(query);
			
			int y = 0;
			int cs=1;
			if(cityStatus.equals("Land")){
				cs = 0;
			}
			while(sa.next()){
				for(int x = 0;x<7;x++){
					LP_Probabilities[LP][cs][x][y] = Float.parseFloat(sa.getString(x+2).replace(",", "."));
					
				}
				y++;
			}
			stmt.close();
			con.close();
		}catch(Exception e){
			e.printStackTrace();
		}
	}
	
	private void checkLP(){
		for(int LP = 0; LP<7;LP++){
			System.out.println("\nLP: "+LP);
			for(int cs = 0; cs<2;cs++){
				System.out.println("LP: "+LP+" city status: "+cs);
				for(int y=0;y<9;y++){
					System.out.println();
					for(int x = 0;x<7;x++){
						System.out.print(" "+LP_Probabilities[LP][cs][x][y]);
					}
				}
				System.out.println();
			}
		}
	}
	
	/**
	 * Reads in the budget per life phase from the database.
	 */
	private void readLPBudget(int LP){
		try{
			Class.forName("com.mysql.jdbc.Driver").newInstance();
			Connection con = DriverManager.getConnection(database);
			Statement stmt = con.createStatement();
			String query = "select count(distinct round(budget)) from LP"+LP+"Budget";
			ResultSet sa = stmt. executeQuery(query);
			sa.next();
			float[][] budget = new float[8][sa.getInt(1)];
			
			query = " select ROUND(budget) as budget, sum(round(14b19Jahre,1)) as 14b19Jahre, sum(round(20b29Jahre,1)) as 20b29Jahre, sum(round(30b39Jahre,1)) as 30b39Jahre, sum(round(40b49Jahre,1)) as 40b49Jahre, sum(round(50b59Jahre,1)) as 50b59Jahre, sum(round(60b69Jahre,1)) as 60b69Jahre, sum(round(70undaelter,1)) as 70undaelter from LP"+LP+"Budget group by round(budget)";
			
			sa = stmt. executeQuery(query);
			int y = 0;
			while(sa.next()){
				for(int x = 0;x<8;x++){
					budget[x][y] = (float)(sa.getDouble(x+1));
				}
				y++;
			}
			lpBudget.put((Integer)LP, budget);
			stmt.close();
			con.close();
		}catch(Exception e){
			e.printStackTrace();
		}
	}
	
	private void checkLPBudget(){
		try{
			for(int LP = 1; LP<8;LP++){
				float[][] budget = lpBudget.get(LP);
				System.out.println("LP: "+LP+"\n");
				for(int y = 0;y<budget[0].length;y++){
					for(int x = 0; x<budget.length;x++){
						System.out.print(budget[x][y]+" ");
					}
					System.out.println();
				}
			}
		}
		catch(Exception e){
			e.printStackTrace();
		}
	}
	
	
	/**
	 * Writes all active destinations into the Hashmap.
	 */
	private void checkActiveDests(){
		HashMap<Integer,DATA_Destination> activedests = new HashMap<Integer, DATA_Destination>();
		for(Entry<Integer, DATA_Destination> dest:activedests.entrySet()){
			if(switchOffCountries.containsKey(dest.getValue().country)){
				if(switchOffCountries.get(dest.getValue().country)<=simulationTime().getYear()){
					activedests.remove(dest.getValue());
				}
			}
		}
	}
	
	
	/**
	 * Reads the additional Attributes of the sourceAreas from the database
	 */
	private void initSourceAreasFromDataBase(){
		try {
            
			Class.forName("com.mysql.jdbc.Driver").newInstance();
			Connection con = DriverManager.getConnection(database);
			Statement stmt = con.createStatement();
			
			String query = " select * from "+sourceareaTable+
					" natural join "+landkreisIDtoSourceAreaIDTable+" natural join "+ buyingpower+";";
			
			ResultSet sa = stmt. executeQuery(query);
			int i = 1;
			while(sa.next()&&i<=actorMap().size()){
//				System.out.println(sa.getString(1)+sa.getString(2)+sa.getString(3)+sa.getString(4)+sa.getString(5));
				DA_SourceArea currentActor =(DA_SourceArea)(actorMap().getEntry(Integer.parseInt(sa.getString("RekurID"))));
				currentActor.name = sa.getString("Landkreis");
				currentActor.cityStatus =Integer.parseInt(sa.getString("Stadt"));
				currentActor.landkreisId = Integer.parseInt(sa.getString("ID"));
				try{
					currentActor.size = Float.parseFloat(sa.getString(3));
				}
				catch(Exception e){
					currentActor.size = 0.0f;
					e.printStackTrace();
				}
				try{
					currentActor.buyingPower = new int [buyingpowercatbuttom.length];
					for(int z = 0;z < buyingpowercatbuttom.length; z++){
						currentActor.buyingPower[z] = Integer.parseInt(sa.getString("kk"+buyingpowercatbuttom[z]+"_"+buyingpowercattop[z]));
					}
				}	
				catch(Exception e){
					//currentActor.buyingPower = 0.0f;
					e.printStackTrace();
				}
				try{
					String ns = sa.getString("NS");
					if(ns.equals("N")){
						currentActor.location = 1;
					}
					if(ns.equals("S")){
						currentActor.location = 2;
					}
				}
				catch(Exception e){
					
				}
				i++;
				//System.out.println(sa.getString("RekurID"));
				initDistances(currentActor);
			}
//			checkDistances();
//			checkBuyingPower();
			con.close();
		} catch (Exception ex) {
            // Fehler behandeln
			ex.printStackTrace();
		}
	}
	
	private void checkBuyingPower(){
		for(Actor entry :actorMap().getEntries()){
			DA_SourceArea sa = (DA_SourceArea)entry;
			int i = 0;
			for(int bp:sa.buyingPower){
				System.out.println(sa.landkreisId+" "+buyingpowercatbuttom[i]+"_"+buyingpowercattop[i]+" "+bp);
				i++;
			}
		}
	}
	
	private void checkCityStatus(){
		for(Actor entry :actorMap().getEntries()){
			DA_SourceArea sa = (DA_SourceArea)entry;
			System.out.println(sa.landkreisId+" "+sa.cityStatus);
		}
	}
	/**
	 * Reads the distance matrix (distance in m).
	 */
	private void readDistancematrix(){
		try{
			Class.forName("com.mysql.jdbc.Driver").newInstance();
			Connection con = DriverManager.getConnection(database);
			Statement stmt = con.createStatement();
			
			String query = " select REKURID,`Schleswig-Holstein`,Nuernberg,Munich from destinations natural join distanceMatrix;";
			ResultSet sa = stmt. executeQuery(query);
			while(sa.next()){
				int destID = Integer.parseInt(sa.getString(1));
				HashMap<Integer, Integer> dest = new HashMap<Integer, Integer>();
				for (int i=2;i<5;i++){
					if(distanceMatrix.containsKey(i-2)){
						distanceMatrix.get(i-2).put(destID, Integer.parseInt(sa.getString(i)));
					}
					else{
						distanceMatrix.put(destID, dest);
					}
				}
			}
		con.close();
		}
		catch(Exception e){
			e.printStackTrace();
		}
	}
	
	/**
	 * Reads the subsidiary costs per country from the database.
	 */
	private void readNKLaender(){
		try{
			Class.forName("com.mysql.jdbc.Driver").newInstance();
			Connection con = DriverManager.getConnection(database);
			Statement stmt = con.createStatement();
			
			String query = " select distinct(landid),round(nkrel) from destinations natural join nklaender;";
			ResultSet sa = stmt. executeQuery(query);
			while(sa.next()){
				nklaender.put(Integer.parseInt(sa.getString(1)),(int)sa.getDouble(2));
			}
		con.close();
		}
		catch(Exception e){
			e.printStackTrace();
		}
	}
	
	/**
	 * Reads the relative capacity per dest.
	 */
	private void readRelCapacity(){
		try{
			Class.forName("com.mysql.jdbc.Driver").newInstance();
			Connection con = DriverManager.getConnection(database);
			Statement stmt = con.createStatement();
			
			String query = " select rekurid, groessenbewertung from `SeasonalityDID`";
			ResultSet sa = stmt. executeQuery(query);
			while(sa.next()){
				relCapacity.put(sa.getInt(1),sa.getInt(2));
			}
		con.close();
		}
		catch(Exception e){
			e.printStackTrace();
		}
	}
	
	/**
	 * Read the distance rates per life phase.
	 */
	private void readLPEntfernungen(){
		try{
			Class.forName("com.mysql.jdbc.Driver").newInstance();
			Connection con = DriverManager.getConnection(database);
			Statement stmt = con.createStatement();
			
			String query = " select * from LpEntfernungen;";
			ResultSet sa = stmt. executeQuery(query);
			int y=0;
			while(sa.next()){
				for(int i = 0; i<3;i++){
					LPentfernungen[y][i] = sa.getDouble(i+2);
				}
				y++;
			}
		con.close();
		}
		catch(Exception e){
			e.printStackTrace();
		}
	}
	
	/**
	 * Reads in the price per km
	 */
	private void readPricePerKM(){
		try{
			Class.forName("com.mysql.jdbc.Driver").newInstance();
			Connection con = DriverManager.getConnection(database);
			Statement stmt = con.createStatement();
			
			String query = " select * from LpEntfernungen;";
			ResultSet sa = stmt. executeQuery(query);
			int y=0;
			while(sa.next()){
				for(int i = 0; i<3;i++){
					LPentfernungen[y][i] = sa.getDouble(i+2);
				}
				y++;
			}
		con.close();
		}
		catch(Exception e){
			e.printStackTrace();
		}
	}
	/**
	 * Reads the temperature limits per life phase
	 */
	private void readTempLimits(){
		try{
			Class.forName("com.mysql.jdbc.Driver").newInstance();
			Connection con = DriverManager.getConnection(database);
			Statement stmt = con.createStatement();
			
			for(int i = 1;i<=7;i++){
				String query = " select * from LP"+i+"temp;";
				ResultSet sa = stmt. executeQuery(query);
				while(sa.next()){
					Integer[] minmax = new Integer[2];
					minmax[0] = sa.getInt("min");
					minmax[1] = sa.getInt("max");
					if(tempLimits.containsKey(i)){
						tempLimits.get(i).put(new Integer(sa.getInt("id")), minmax);
					}
					else{
						HashMap<Integer,Integer[]> h = new HashMap<Integer, Integer[]>();
						h.put(new Integer(sa.getInt("id")), minmax);
						tempLimits.put(i, h);
					}
				}
			}
		con.close();
		}
		catch(Exception e){
			e.printStackTrace();
		}
	}
	
	
	private void readHTSeason(){
		try{
			Class.forName("com.mysql.jdbc.Driver").newInstance();
			Connection con = DriverManager.getConnection(database);
			Statement stmt = con.createStatement();
			

			String query = " select id, round(jan,1), round(feb,1), round(mar,1), round(apr,1), round(may,1), round(jun,1), round(jul,1), round(aug,1), round(sep,1), round(okt,1), round(nov,1), round(`dec`,1) from htseason";
			ResultSet sa = stmt. executeQuery(query);
			while(sa.next()){
				double[] months = new double[12];
				for(int i = 0;i<12;i++){
					months[i]=sa.getDouble(i+2);
				}
				
				htSeason.put(Integer.parseInt(sa.getString("id")), months);
			}
		con.close();
		}
		catch(Exception e){
			e.printStackTrace();
		}
	}
	
	
	/**
	 * Reads in the distances to each destination in Minutes.
	 * @param currentActor the sourcearea.
	 */
	private void initDistances(DA_SourceArea currentActor){
		try{
			Class.forName("com.mysql.jdbc.Driver").newInstance();
			Connection con = DriverManager.getConnection(database);
			Statement stmt = con.createStatement();
			
			String query = " select destination_rownumber,distanceinminutes from "+distance+" where kreis_id ="+currentActor.landkreisId+";";
			ResultSet sa = stmt. executeQuery(query);
			while(sa.next()){
				currentActor.distance.put(Integer.parseInt(sa.getString("DESTINATION_ROWNUMBER")), (int)(Float.parseFloat(sa.getString("distanceinminutes"))));
			}
		con.close();
		}
		catch(Exception e){
			e.printStackTrace();
		}
	}
	/**
	 * Method to check the distance matrix.
	 */
	private void checkDistances(){
		for(Actor entry :actorMap().getEntries()){
			DA_SourceArea sa = (DA_SourceArea)entry;
			for(Entry<Integer, Integer> dist:sa.distance.entrySet()){
				System.out.println(sa.landkreisId+" "+dist.getKey()+" "+dist.getValue());
			}
		}
	}
	
	/**
	 * Updates the Demography for this year
	 * @param year current simulation year
	 */
	
	public void updateDemography(int year){
		try {
			Class.forName("com.mysql.jdbc.Driver").newInstance();
			Connection con = DriverManager.getConnection(database);
			Statement stmt = con.createStatement();
			for(Actor a:actorMap().getEntries()){
				DA_SourceArea currentArea = (DA_SourceArea)a;
				String query = " select m"+year+",w"+year+" from d"+currentArea.landkreisId;
				
				ResultSet sa = stmt. executeQuery(query);
				int i = 0;
				int popBucket = currentArea.cityStatus;
				
				while(sa.next()){
					//System.out.println(i);
					if(sa.getString("m"+year).equals("") || sa.getString("w"+year).equals("")){
//						System.out.println(currentArea.landkreisId+" "+i);
					}
					else{
						//Integer t = type;
						
						//Integer[][] percArray=(tm.typeSpreading.get(t));
						//int percentage = percArray[popBucket][ageBucket];
						//int popPerType = (i*percentage)/100;
						
						int ageBucket=-1;
						for(int b = 0; b<agestruct.length;b++){
							if(i>=agestruct[b]){
								ageBucket++;
							}
						}
						
						
						int m = (Integer.parseInt(sa.getString("m"+year))+5)/10;
						int w = (Integer.parseInt(sa.getString("w"+year))+5)/10;
						if(i == 0){
							for(int z = 0; z<currentArea.numberOfTypes;z++){
								Integer[][] percArray=(typeSpreading.get(z));
								int percentage = percArray[popBucket][ageBucket];
								int pm = (m*percentage)/100;
								int pw = (w*percentage)/100;
								currentArea.populationPerAgeAndSexDifference[i][0][z] = pm;
								currentArea.populationPerAgeAndSexDifference[i][1][z] = pw;
							}
							
						}
						if(i>0 && i < 90){
							for(int z = 0; z<currentArea.numberOfTypes;z++){
								Integer[][] percArray=(typeSpreading.get(z));
								int percentage = percArray[popBucket][ageBucket];
								int pm = (m*percentage)/100;
								int pw = (w*percentage)/100;
								currentArea.populationPerAgeAndSexDifference[i][0][z] = pm - currentArea.lastYearpop[i-1][0][z];
								currentArea.populationPerAgeAndSexDifference[i][1][z] = pw - currentArea.lastYearpop[i-1][1][z];
							}
						}
						if(i == 90){
							for(int z = 0; z<currentArea.numberOfTypes;z++){
								Integer[][] percArray=(typeSpreading.get(z));
								int percentage = percArray[popBucket][ageBucket];
								int pm = (m*percentage)/100;
								int pw = (w*percentage)/100;
								currentArea.populationPerAgeAndSexDifference[i][0][z] = pm - (currentArea.lastYearpop[i-1][0][z]+currentArea.lastYearpop[i][0][z]);
								currentArea.populationPerAgeAndSexDifference[i][1][z] = pw - (currentArea.lastYearpop[i-1][1][z]+currentArea.lastYearpop[i][1][z]);
							}
						}
						if(i==91){	
							currentArea.numberOfCitizensDiff[0] = m - currentArea.numberOfCitizens[0];
							currentArea.numberOfCitizensDiff[1] = w - currentArea.numberOfCitizens[1];
							currentArea.numberOfCitizens[0]= m;
							currentArea.numberOfCitizens[1]= w;
						}
						else{
							for(int z = 0; z<currentArea.numberOfTypes;z++){
								Integer[][] percArray=(typeSpreading.get(z));
								int percentage = percArray[popBucket][ageBucket];
								int pm = (m*percentage)/100;
								int pw = (w*percentage)/100;
								currentArea.populationPerAgeAndSex[i][0][z] = pm;
								currentArea.populationPerAgeAndSex[i][1][z] = pw;
							}
						}
					}
					i++;
				}
				
			}
		con.close();
		} catch (Exception ex) {
	        // Fehler behandeln
			ex.printStackTrace();
			System.out.println("Error");
		}
	}
	
	/**
	 * This Method initializes all Tourist Agents.
	 */
	private void initTourists(){
		
		for(DA_SourceArea sa : actorMap().getEntries(DA_SourceArea.class).getEntries()){
			sa.initTourists(this);
		}
	}
	
	
	/**
	 * This methods reads in all TouristTypes from the database.
	 */
	private void initTouristTypes(){
		try {
			Class.forName("com.mysql.jdbc.Driver").newInstance();
			Connection con = DriverManager.getConnection(database);
			Statement stmt = con.createStatement();
			String query = "select * from "+touristTypesTable;
			
			ResultSet sa = stmt. executeQuery(query);
			while(sa.next()){
				DA_AbstractTouristType ttype = (DA_AbstractTouristType)Class.forName(sa.getString("Class")).newInstance();
				try{
					ttype.holidaytypes = addToVector(sa.getString("holidaytypes"));
				}
				catch(Exception e){
					logger().debug(e.getMessage());
				}
				try{
					ttype.activityTypes = addToVector(sa.getString("activityTypes"));
				}
				catch(Exception e){
					logger().debug(e.getMessage());
				}
				try{
					ttype.countries = addToVector(sa.getString("countries"));
				}
				catch(Exception e){
					logger().debug(e.getMessage());
				}
				try{
					ttype.tcp.airTemperatureMax = Integer.parseInt(sa.getString("maxTemp"));
				}
				catch(Exception e){
					logger().debug(e.getMessage());
				}
				try{
					ttype.tcp.airTemperatureMin = Integer.parseInt(sa.getString("minTemp"));
				}
				catch(Exception e){
					logger().debug(e.getMessage());
				}
				try{
					ttype.tcp.airTemperatureMean = Integer.parseInt(sa.getString("avgTemp"));
				}
				catch(Exception e){
					logger().debug(e.getMessage());
				}
				try{
					ttype.preferedJourneyWeeks = addToVector(sa.getString("preferedWeeks"));
				}
				catch(Exception e){
					logger().debug(e.getMessage());
				}
				try{
					ttype.holidayLength = Integer.parseInt(sa.getString("holidayLength"));
				}
				catch(Exception e){
					logger().debug(e.getMessage());
				}
				try{
					ttype.category = Integer.parseInt(sa.getString("category"));
				}
				catch(Exception e){
					logger().debug(e.getMessage());
				}
				try{
					ttype.bookingMonth = Integer.parseInt(sa.getString("bookingMonth"));
				}
				catch(Exception e){
					logger().debug(e.getMessage());
				}
				try{
					ttype.bookingDay = Integer.parseInt(sa.getString("bookingDay"));
				}
				catch(Exception e){
					logger().debug(e.getMessage());
				}
				try{
					ttype.ID = Integer.parseInt(sa.getString("ID"));
				}
				catch(Exception e){
					logger().debug(e.getMessage());
				}
				
				try{
					ttype.travelProbability = Integer.parseInt(sa.getString("travelProbability"));
					ttype.currentProbability = ttype.travelProbability;
				}
				catch(Exception e){
					logger().debug(e.getMessage());
				}
				
				try{
					String iF = sa.getString("probIncrease").replace(",", ".");
					ttype.increaseFactor = Double.parseDouble(iF);
				}
				catch(Exception e){
					logger().debug(e.getMessage());
				}
				
				touristTypes.put(Integer.parseInt(sa.getString("ID")), ttype);
			}
		con.close();	
		} catch (Exception ex) {
	        // Fehler behandeln
			ex.printStackTrace();
			System.out.println("Error");
		}
	}
	
	private void checkSpreading(){
		try{
			for(Entry<Integer, Integer[][]> e:typeSpreading.entrySet()){
				System.out.println(e.getKey());
				for(Integer[] i :e.getValue()){
					for(int z : i){
						System.out.print(z+" ");
					}
					System.out.println();
				}
			}
		}catch(Exception ex){
			ex.printStackTrace();
		}
		
	}
	
	
	private void readSpreading(){
		try {
			Class.forName("com.mysql.jdbc.Driver").newInstance();
			Connection con = DriverManager.getConnection(database);
			Statement stmt = con.createStatement();
			for(Entry<Integer, DA_AbstractTouristType> e:touristTypes.entrySet()){
			
				String query = "select * from "+lessThan50000+" where ID = '"+e.getKey()+"'";
				
				ResultSet sa = stmt. executeQuery(query);
				Integer[][] newType = new Integer[2][6];
				while(sa.next()){
					int count = sa.getMetaData().getColumnCount();
					newType = new Integer[2][count-2];
					for(int i = 3; i<=count ; i++){
						newType[0][i-3] = (int)(Double.parseDouble(sa.getString(i))*100.0);
						
					}
				}
				query = "select * from "+moreThan50000+" where ID = '"+e.getKey()+"'";
				sa = stmt. executeQuery(query);
				while(sa.next()){
					int count = sa.getMetaData().getColumnCount();
					for(int i = 3; i<=count ; i++){
						newType[1][i-3] = (int)(Double.parseDouble(sa.getString(i))*100.0);
					}
				}
				typeSpreading.put(e.getKey(),newType);
				//checkSpreading();
			}
			stmt.close();
			con.close();
		}catch(Exception ex){
				ex.printStackTrace();
		}
			
	}
	
	
	/**
	 * Adds int values out of a string seperated by ",".
	 * @param ints String with int-values
	 * @return a Vector<Integer> with all values.
	 */
	private Vector<Integer> addToVector(String ints){
		String[] values = ints.split(",", -1);
		Vector<Integer> intVector = new Vector<Integer>();
		for(String intValue:values){
			intVector.add(Integer.parseInt(intValue));
		}
		return intVector;
	}
	
	/**
	 * Writes out the sourcearea map to check the correct initialization
	 */
	private void writemap(){
		FileWriter writeOut;
		String outputName = "sourcearea.asc";
		try{
			writeOut = new FileWriter(outputName, false);
			writeOut.write("");
			writeOut.flush();
			writeOut = new FileWriter(outputName, true);
			
			
			writeOut.write("ncols 	590\n" +
					"nrows 		258\n" +
					"xllcorner     -2868800\n" +
					"yllcorner     200792\n" +
					"cellsize      10000\n" +
					"NODATA_value  1\n");
			
			try{
				for(int i=1;i<(590*258);i++){
					
					boolean inside = proxel(i).isInside();
					if(inside){
						int found = -1;
						for(Actor entry :actorMap().getEntries()){
							for(int id : entry.getLocation().getPIDArray()){
								if(id == i){
									found = entry.getId();
								}
							}
						}
						if(found!=-1){
							writeOut.write(" "+found);
						}
						else{
							writeOut.write(" "+0);
						}
					}
					else{
						writeOut.write(" "+"1");
					}
					if(i%590==0){
						writeOut.write("\n");
					}
				}
			}
			catch(Exception e){
				writeOut.write(e.getMessage());
			}	
			
			writeOut.flush();
			writeOut.close();
			
			
		}
		catch(Exception e){
			System.out.println(e);
		}
	}
	
	/**
	 * This Method is called to put a Tourist in a destination.
	 * @param tourist The traveling tourist.
	 */
	public void setDestinationChanged(DA_Tourist tourist){
		booked = true;
		DATA_Destination journeyDest = destinations.get(tourist.nextJourney.destID);
		for(Entry<Integer, Vector<Integer>> weeksOfYear: tourist.nextJourney.weeks.entrySet()){
			for(int i : weeksOfYear.getValue()){
				HashMap<Integer, HashMap<Integer, Vector<Journey>>> journeyPerWeekAndCat;
				if(journeyDest.bookingJourneys.containsKey(weeksOfYear.getKey())){
					journeyPerWeekAndCat = journeyDest.bookingJourneys.get(weeksOfYear.getKey());
				}
				else{
					journeyPerWeekAndCat = new HashMap<Integer, HashMap<Integer,Vector<Journey>>>();
				}
				
				HashMap<Integer, Vector<Journey>> journeyPerCat;
				if(journeyPerWeekAndCat.containsKey(i)){
					journeyPerCat = journeyPerWeekAndCat.get(i);
				}
				else{
					journeyPerCat = new HashMap<Integer, Vector<Journey>>();
				}
				if(journeyPerCat.containsKey(tourist.nextJourney.category)){
					Vector<Journey> journeys = journeyPerCat.get(tourist.nextJourney.category);
					journeys.add(tourist.nextJourney);
					journeyPerCat.put(tourist.nextJourney.category, journeys);
				}
				else{
					Vector<Journey> journeys = new Vector<Journey>();
					journeys.add(tourist.nextJourney);
					journeyPerCat.put(tourist.nextJourney.category, journeys);
				}
				//System.out.println(tourist.nextJourney.SourceAreaID);
				journeyPerWeekAndCat.put(i, journeyPerCat);
				journeyDest.bookingJourneys.put(weeksOfYear.getKey(), journeyPerWeekAndCat);
			}
		}
	}
	
	/* (non-Javadoc)
	 * @see org.glowa.danube.deepactors.model.AbstractActorModel#getData()
	 */
	public void getData() {
//		System.out.println("TouristGetData");
//		compute = true;
		if(destinationInit){
			int i = 0;
			for(Entry<Integer, boolean[]> entry:controller.getHolidayTypes().entrySet()){
				DATA_Destination currentDest = new DATA_Destination();
				currentDest = new DATA_Destination();
				if(entry.getValue()==null){
					System.out.println(entry.getKey()+" Entry.getValue() ist null");
				}
				currentDest.holidayTypes = entry.getValue();
				currentDest.id = (int)entry.getKey();
				currentDest.country = controller.getCountryIDs().get(entry.getKey());
				currentDest.costs = controller.getCosts().get(entry.getKey());
				destinations.put(entry.getKey(), currentDest);
				i++;
				//System.out.println(text);
			}
			activedests = destinations;
			destinationInit = false;
		}
		for(Entry<Integer, ClimateData> dailyClimate: controller.getDailyClimateData().entrySet()){
			destinations.get(dailyClimate.getKey()).updateDailyClimate(dailyClimate.getValue());
			
			if(simulationTime().getDay()==2){
				destinations.get(dailyClimate.getKey()).updateMonthlyClimate(simulationTime().getYear(), simulationTime().getMonth(), controller.getLastMonthClimateData().get(dailyClimate.getKey()));
			}
		}
		//System.out.println(preSimulation);
		if(preSimulation && startDay == simulationTime().getDay() && startMonth == simulationTime().getMonth() && 
			startYear+preSimulationTime == simulationTime().getYear()){	
					preSimulation = false;
		}
		
		try {
			getDaylyDataEngine.getData();
		} catch (Exception ex) {
			this.logger().warn(ex);
		}
		
		
	}

	
	/**
	 * getData engine parallelizes the import of the ClimateData provided by the ClimateModel via ModelController. 
	 */
	
	private GetDataEngine getDaylyDataEngine = new GetDataEngine();
    {
		
    	
//    	MeanTemp
    	getDaylyDataEngine.add(new ProvideTask()
    	{
    		public void run()
    		{
    			TemperatureTable airTemperatureDailyMean = controller.getAirTemperatureDailyMean();
    			for(int i:pids()){ 
					proxel(i).cd.airTemperatureMean = airTemperatureDailyMean.getValueByIndex(i);
				}
    		}
    	});
//    	MaxTemp
    	getDaylyDataEngine.add(new ProvideTask()
    	{
    		public void run()
    		{
    			TemperatureTable airTemperatureDailyMax= controller.getAirTemperatureDailyMax();
    			for(int i:pids()){ 
					proxel(i).cd.airTemperatureMax = airTemperatureDailyMax.getValueByIndex(i);
				}
    		}
    	});
//    	MinTemp
    	getDaylyDataEngine.add(new ProvideTask()
    	{
    		public void run()
    		{
    			TemperatureTable airTemperatureDailyMin = controller.getAirTemperatureDailyMin();
    			for(int i:pids()){
					proxel(i).cd.airTemperatureMin = airTemperatureDailyMin.getValueByIndex(i);
				}
    		}
    	});
//    	PrecepSum
    	getDaylyDataEngine.add(new ProvideTask()
    	{
    		public void run()
    		{
    			MassPerAreaTable precipitationDailySum = controller.getPrecipitationDailySum();
    			for(int i:pids()){
    				proxel(i).cd.precipitationSum = precipitationDailySum.getValueByIndex(i);
				}
    		}
    	});
//    	SunDurance
    	getDaylyDataEngine.add(new ProvideTask()
    	{
    		public void run()
    		{
    			FloatDataTable sunshineDurationDailySum = controller.getSunshineDurationDailySum();
    			for(int i:pids()){
    				proxel(i).cd.sunshineDurationSum = sunshineDurationDailySum.getValueByIndex(i);
				}
    		}
    	});
//    	MeanWindSpeed
    	getDaylyDataEngine.add(new ProvideTask()
    	{
    		public void run()
    		{
    			FloatDataTable windSpeedDailyMean = controller.getWindSpeedDailyMean();
    			for(int i:pids()){
					proxel(i).cd.windSpeedMean = windSpeedDailyMean.getValueByIndex(i);
				}
    		}
    	});
//    	MaxWindSpeed
    	getDaylyDataEngine.add(new ProvideTask()
    	{
    		public void run()
    		{
    			FloatDataTable windSpeedDailyMax = controller.getWindSpeedDailyMax();
    			for(int i:pids()){
					proxel(i).cd.windSpeedMax = windSpeedDailyMax.getValueByIndex(i);
				}
    		}
    	});
//    	RelativeHumidity
    	getDaylyDataEngine.add(new ProvideTask()
    	{
    		public void run()
    		{
    			FloatDataTable relativeHuminityDailyMean = controller.getRelativeHumidityDailyMean();
    			for(int i:pids()){
    				proxel(i).cd.relativeHumidityMean = relativeHuminityDailyMean.getValueByIndex(i);
				}
    		}
    	});
    	
//    	TemperatureHumidityIndex
    	getDaylyDataEngine.add(new ProvideTask()
    	{
    		public void run()
    		{
    			IntegerDataTable temperatureHumidityIndex = controller.getTempHumidityIndex();
    			for(int i:pids()){
    				proxel(i).cd.temperatureHumidityIndex = temperatureHumidityIndex.getValueByIndex(i);
				}
    		}
    	});
    	
//    	TemperatureHumidityIndex
    	getDaylyDataEngine.add(new ProvideTask()
    	{
    		public void run()
    		{
    			IntegerDataTable tourismClimateIndex = controller.getTourismClimateIndex();
    			for(int i:pids()){ 
    				proxel(i).cd.TCI = tourismClimateIndex.getValueByIndex(i);
				}
    		}
    	});
    	
    	getDaylyDataEngine.add(new ProvideTask()
    	{
    		public void run()
    		{
    			if(simulationTime().getMonth() == 1 && simulationTime().getDay() == 1){
    				 //System.out.println(""+ day+" "+month+" "+year);
    				 updateDemography(simulationTime().getYear());
    				 checkActiveDests();
    			 }
    		}
    	});
    }
	
	
	
	/* (non-Javadoc)
	 * @see org.glowa.danube.deepactors.model.AbstractActorModel#preCompute()
	 */
	protected void preCompute() {
		updateCurrentDate();
		booked = false;
	}
	/**
	 * This methods updates the current Gregorian Calendar.
	 */
	private void updateCurrentDate(){
		int month = this.simulationTime().getMonth();
		 int year = this.simulationTime().getYear();
		 int day = this.simulationTime().getDay();
		 
		 currentDate = new GregorianCalendar(year, month-1, day-1);
		 currentDate.setMinimalDaysInFirstWeek(4);
		 currentDate.setFirstDayOfWeek(1);
	}
	
	/* (non-Javadoc)
	 * @see org.glowa.danube.deepactors.model.AbstractActorModel#postCompute()
	 */
	protected void postCompute(){
		if(simulationTime().getMonth()==1 && simulationTime().getDay()==2){
			for(Entry<Integer, DATA_Destination> dests:destinations.entrySet()){
				
				//if(debug)writeMonthlyClimateData(simulationTime());
				if(dests.getValue().touristsPerTimeSourceAndCat.containsKey(simulationTime().getYear()-3)){
					dests.getValue().touristsPerTimeSourceAndCat.remove(simulationTime().getYear()-3);
				}
			}
			touristPerDest = new HashMap<Integer, HashMap<Integer,HashMap<Integer,HashMap<Integer,HashMap<Integer,HashMap<Integer,HashMap<Integer,HashMap<Integer,Integer[]>>>>>>>>();
			for(Entry<Integer, DATA_Destination> dests:destinations.entrySet()){
				touristPerDest.put(dests.getKey(), dests.getValue().touristsPerTimeSourceAndCat);
			}
		}
		if(booked){
//			while(redecide){
//				redecide = false;
//				redecideProcess();
//			}
			journeyCounter();
		}
		//if(debug)writeDailyClimateData(simulationTime());
		writeDailyClimateData(simulationTime());
		if(simulationTime().getDay()==2){
			//if(debug)writeMonthlyClimateData(simulationTime());
			writeMonthlyClimateData(simulationTime());
		}
	}
	
	/**
	 * Method to write our the daily climate data for debugging.
	 * @param actTime
	 */
	private void writeDailyClimateData(DanubiaCalendar actTime){
		try{
			Class.forName("com.mysql.jdbc.Driver").newInstance();
			Connection con = DriverManager.getConnection(database);
			Statement stmt = con.createStatement();
			if (firstday) {
				firstday = false;
				try{
				  stmt.executeUpdate("DROP TABLE "+"SourceDailyClimateData_"+climatescenario);
				}
				catch(Exception e){}
				try {
					String table = "CREATE TABLE SourceDailyClimateData_"+climatescenario+"("+ "ActorID INTEGER, "+ " Date DATE, "+ "MeanTemp FLOAT(6,1), "+ "MaxTemp FLOAT(6,1), "+ "MinTemp FLOAT(6,1), "+ "precipSum FLOAT(6,2), "+ "precipMax FLOAT(6,2), "+ "sunDuranceSum FLOAT(6,1), "+ "windSpeedMean FLOAT(6,2), "+ "WindSpeedMax FLOAT(6,2), "+ "relHum FLOAT(6,2), "+ "THI FLOAT(6,1), "+ "watertemp FLOAT(6,1), "+ "TCI INTEGER)";
					stmt.executeUpdate(table);
				}
				catch (Exception ex) {
				ex.printStackTrace();
				}
			} else {	
		for(Actor a : actorMap().getEntries()){
			String table = "INSERT INTO SourceDailyClimateData_"+climatescenario+" \n"+"VALUES(";
			DA_SourceArea d = (DA_SourceArea)a;
			table+=d.getId()+
					","+"'"+actTime.getYear()+"-"+actTime.getMonth()+"-"+actTime.getDay()+"'"+
					","+d.ca.dailyClimate.airTemperatureMean+
					","+d.ca.dailyClimate.airTemperatureMax+
					","+d.ca.dailyClimate.airTemperatureMin+
					","+d.ca.dailyClimate.precipitationSum+
					","+d.ca.dailyClimate.precipitationMax+
					","+d.ca.dailyClimate.sunshineDurationSum+
					","+d.ca.dailyClimate.windSpeedMean+
					","+d.ca.dailyClimate.windSpeedMax+
					","+d.ca.dailyClimate.relativeHumidityMean+
					","+d.ca.dailyClimate.temperatureHumidityIndex+
					","+d.ca.dailyClimate.watertemp+
					","+d.ca.dailyClimate.TCI+
					"\n"+")";
			stmt.executeUpdate(table);
			}
		con.close();
		}}
		catch (Exception e) {
		e.printStackTrace();
		}
	}	
	
//    	FileWriter writeOut;
//		String outputName = "ClimateData"+File.separator+"SourceAreaData"+actTime.getDay()+actTime.getMonth()+actTime.getYear()+".csv"; 
//		try{
//			writeOut = new FileWriter(outputName, false);
//			writeOut.write("");
//			writeOut.flush();
//			writeOut = new FileWriter(outputName, true);
//			
//			writeOut.write("ActorID;MeanTemp;MaxTemp;MinTemp;precipSum;precipMax;sunDuranceSum;windSpeedMean;WindSpeedMax;relHum;THI;watertemp;TCI\n");
//			for(Actor a : actorMap().getEntries()){
//				DA_SourceArea d = (DA_SourceArea)a;
//				writeOut.write(d.getId()+";"+RekurUtil.dotToComma(d.ca.dailyClimate.airTemperatureMean)+
//						";"+RekurUtil.dotToComma(d.ca.dailyClimate.airTemperatureMax)+
//						";"+RekurUtil.dotToComma(d.ca.dailyClimate.airTemperatureMin)+
//						";"+RekurUtil.dotToComma(d.ca.dailyClimate.precipitationSum)+
//						";"+RekurUtil.dotToComma(d.ca.dailyClimate.precipitationMax)+
//						";"+RekurUtil.dotToComma(d.ca.dailyClimate.sunshineDurationSum)+
//						";"+RekurUtil.dotToComma(d.ca.dailyClimate.windSpeedMean)+
//						";"+RekurUtil.dotToComma(d.ca.dailyClimate.windSpeedMax)+
//						";"+RekurUtil.dotToComma(d.ca.dailyClimate.relativeHumidityMean)+
//						";"+RekurUtil.dotToComma(d.ca.dailyClimate.temperatureHumidityIndex)+
//						";"+RekurUtil.dotToComma(d.ca.dailyClimate.watertemp)+
//						";"+RekurUtil.dotToComma(d.ca.dailyClimate.TCI)+
//						"\n");	
//			}
//			
//			writeOut.flush();
//			writeOut.close();
//		}catch(Exception e){System.out.println(e);}
//    }
	
	/**
	 * Method to write our the monthly climate data for debugging.
	 * @param actTime
	 */
	private void writeMonthlyClimateData(DanubiaCalendar actTime){
		try{
			Class.forName("com.mysql.jdbc.Driver").newInstance();
			Connection con = DriverManager.getConnection(database);
			Statement stmt = con.createStatement();
			if (firstmonth) {
				firstmonth = false;
			try{
				  stmt.executeUpdate("DROP TABLE "+"SourceMonthlyClimateData_"+climatescenario);
			}
			catch(Exception e){}
				try {
					String table = "CREATE TABLE SourceMonthlyClimateData_"+climatescenario+"("+ "ActorID INTEGER, "+ " Date DATE, "+ "MeanTemp FLOAT(6,1), "+ "MaxTemp FLOAT(6,1), "+ "MinTemp FLOAT(6,1), "+ "precipSum FLOAT(6,2), "+ "precipMax FLOAT(6,2), "+ "sunDuranceSum FLOAT(6,1), "+ "windSpeedMean FLOAT(6,2), "+ "WindSpeedMax FLOAT(6,2), "+ "relHum FLOAT(6,2), "+ "THI FLOAT(6,1), "+ "watertemp FLOAT(6,1), "+ "TCI INTEGER)";
					stmt.executeUpdate(table);
				}
				catch (Exception ex) {
				ex.printStackTrace();
				}
			} else {
				
		for(Actor a : actorMap().getEntries()){
			String table = "INSERT INTO SourceMonthlyClimateData_"+climatescenario+" \n"+"VALUES(";
			DA_SourceArea d = (DA_SourceArea)a;
			table+=d.getId()+
					","+"'"+actTime.getYear()+"-"+actTime.getMonth()+"-"+"00"+"'"+
					","+d.ca.lastMonthClimate.airTemperatureMean+						// ","+"d.ca.dailyClimate.airTemperatureMean"+
					","+d.ca.lastMonthClimate.airTemperatureMax+
					","+d.ca.lastMonthClimate.airTemperatureMin+
					","+d.ca.lastMonthClimate.precipitationSum+
					","+d.ca.lastMonthClimate.precipitationMax+
					","+d.ca.lastMonthClimate.sunshineDurationSum+
					","+d.ca.lastMonthClimate.windSpeedMean+
					","+d.ca.lastMonthClimate.windSpeedMax+
					","+d.ca.lastMonthClimate.relativeHumidityMean+
					","+d.ca.lastMonthClimate.temperatureHumidityIndex+
					","+d.ca.lastMonthClimate.watertemp+
					","+d.ca.lastMonthClimate.TCI+
					"\n"+")";
			stmt.executeUpdate(table);
			}
		con.close();
		}}
		catch (Exception e) {
		e.printStackTrace();
		}
	}	
	
//    	FileWriter writeOut;
//		String outputName = "ClimateData"+File.separator+"SourceAreaMonthlyData"+(actTime.getMonth()-1)+actTime.getYear()+".csv"; 
//		try{
//			writeOut = new FileWriter(outputName, false);
//			writeOut.write("");
//			writeOut.flush();
//			writeOut = new FileWriter(outputName, true);
//			
//			writeOut.write("ActorID;MeanTemp;MaxTemp;MinTemp;precipSum;precipMax;sunDuranceSum;windSpeedMean;WindSpeedMax;relHum;THI;watertemp;TCI\n");
//			for(Actor a : actorMap().getEntries()){
//				DA_SourceArea d = (DA_SourceArea)a;
//				writeOut.write(d.getId()+";"+RekurUtil.dotToComma(d.ca.dailyClimate.airTemperatureMean)+
//						";"+RekurUtil.dotToComma(d.ca.lastMonthClimate.airTemperatureMax)+
//						";"+RekurUtil.dotToComma(d.ca.lastMonthClimate.airTemperatureMin)+
//						";"+RekurUtil.dotToComma(d.ca.lastMonthClimate.precipitationSum)+
//						";"+RekurUtil.dotToComma(d.ca.lastMonthClimate.precipitationMax)+
//						";"+RekurUtil.dotToComma(d.ca.lastMonthClimate.sunshineDurationSum)+
//						";"+RekurUtil.dotToComma(d.ca.lastMonthClimate.windSpeedMean)+
//						";"+RekurUtil.dotToComma(d.ca.lastMonthClimate.windSpeedMax)+
//						";"+RekurUtil.dotToComma(d.ca.lastMonthClimate.relativeHumidityMean)+
//						";"+RekurUtil.dotToComma(d.ca.lastMonthClimate.temperatureHumidityIndex)+
//						";"+RekurUtil.dotToComma(d.ca.lastMonthClimate.watertemp)+
//						";"+RekurUtil.dotToComma(d.ca.lastMonthClimate.TCI)+
//						"\n");
//			}
//			
//			writeOut.flush();
//			writeOut.close();
//		}catch(Exception e){System.out.println(e);}
//    }
	
	
	
	/**
	 * This method counts the current booking journeys per year, week, category and sourcearea.
	 */
	private void journeyCounter(){
		
		if(destinations !=null && booked){
			for(Entry<Integer, DATA_Destination> dests:destinations.entrySet()){
				
				if(simulationTime().getMonth()==1 && simulationTime().getDay()==2){
					System.out.println(simulationTime().getYear()-3+" "+dests.getKey());
					//if(debug)writeMonthlyClimateData(simulationTime());
					if(dests.getValue().touristsPerTimeSourceAndCat.containsKey(simulationTime().getYear()-3)){
						dests.getValue().touristsPerTimeSourceAndCat.remove(simulationTime().getYear()-3);
						
					}
				}
				for(Entry<Integer, HashMap<Integer, HashMap<Integer, Vector<Journey>>>> jPerYWC:dests.getValue().bookingJourneys.entrySet()){
					int year = jPerYWC.getKey();
					if(!dests.getValue().touristsPerTimeSourceAndCat.containsKey(jPerYWC.getKey())){
						HashMap<Integer, HashMap<Integer, HashMap<Integer, HashMap<Integer, HashMap<Integer, HashMap<Integer, Integer[]>>>>>> touristsPerCatSourceWeek = new HashMap<Integer, HashMap<Integer,HashMap<Integer,HashMap<Integer,HashMap<Integer,HashMap<Integer,Integer[]>>>>>>();
						dests.getValue().touristsPerTimeSourceAndCat.put(jPerYWC.getKey(), touristsPerCatSourceWeek);
					}
					for(Entry<Integer, HashMap<Integer, Vector<Journey>>> jPerWC: jPerYWC.getValue().entrySet()){
						int week = jPerWC.getKey();
						if(!dests.getValue().touristsPerTimeSourceAndCat.get(jPerYWC.getKey()).containsKey(jPerWC.getKey())){
							HashMap<Integer, HashMap<Integer, HashMap<Integer, HashMap<Integer, HashMap<Integer, Integer[]>>>>> touristsPerCatSource = new HashMap<Integer, HashMap<Integer,HashMap<Integer,HashMap<Integer,HashMap<Integer,Integer[]>>>>>();
							dests.getValue().touristsPerTimeSourceAndCat.get(jPerYWC.getKey()).put(jPerWC.getKey(), touristsPerCatSource);
						}
						
						for(Entry<Integer, Vector<Journey>> jPerC:jPerWC.getValue().entrySet()){
							if(!dests.getValue().touristsPerTimeSourceAndCat.get(jPerYWC.getKey()).get(jPerWC.getKey()).containsKey(jPerC.getKey())){
								HashMap<Integer, HashMap<Integer, HashMap<Integer, HashMap<Integer, Integer[]>>>> touristsPerCat = new HashMap<Integer, HashMap<Integer,HashMap<Integer,HashMap<Integer,Integer[]>>>>();
								dests.getValue().touristsPerTimeSourceAndCat.get(jPerYWC.getKey()).get(jPerWC.getKey()).put(jPerC.getKey(), touristsPerCat);
							}
							for(Journey j:jPerC.getValue()){
								if(!dests.getValue().touristsPerTimeSourceAndCat.get(jPerYWC.getKey()).get(jPerWC.getKey()).get(jPerC.getKey()).containsKey(j.sourceAreaID)){	
									HashMap<Integer, HashMap<Integer, HashMap<Integer,Integer[]>>> touristsPerSource = new HashMap<Integer, HashMap<Integer,HashMap<Integer,Integer[]>>>();
									dests.getValue().touristsPerTimeSourceAndCat.get(jPerYWC.getKey()).get(jPerWC.getKey()).get(jPerC.getKey()).put(j.sourceAreaID,touristsPerSource);
								}
								if(!dests.getValue().touristsPerTimeSourceAndCat.get(jPerYWC.getKey()).get(jPerWC.getKey()).get(jPerC.getKey()).get(j.sourceAreaID).containsKey(j.tourist.currentTouristType.ID)){
									HashMap<Integer, HashMap<Integer,Integer[]>> touristsPerType = new HashMap<Integer, HashMap<Integer,Integer[]>>();
									dests.getValue().touristsPerTimeSourceAndCat.get(jPerYWC.getKey()).get(jPerWC.getKey()).get(jPerC.getKey()).get(j.sourceAreaID).put(j.tourist.currentTouristType.ID, touristsPerType);
								}
								if(!dests.getValue().touristsPerTimeSourceAndCat.get(jPerYWC.getKey()).get(jPerWC.getKey()).get(jPerC.getKey()).get(j.sourceAreaID).get(j.tourist.currentTouristType.ID).containsKey(j.tourist.age)){
									HashMap<Integer,Integer[]> touristsPerAge = new HashMap<Integer,Integer[]>();
									dests.getValue().touristsPerTimeSourceAndCat.get(jPerYWC.getKey()).get(jPerWC.getKey()).get(jPerC.getKey()).get(j.sourceAreaID).get(j.tourist.currentTouristType.ID).put(j.tourist.age, touristsPerAge);
								}
								if(!dests.getValue().touristsPerTimeSourceAndCat.get(jPerYWC.getKey()).get(jPerWC.getKey()).get(jPerC.getKey()).get(j.sourceAreaID).get(j.tourist.currentTouristType.ID).get(j.tourist.age).containsKey(j.tourist.sex)){
									
									if(j.weeks.get(year).get(0)==week){
										Integer[] e = {1,1};
										dests.getValue().touristsPerTimeSourceAndCat.get(jPerYWC.getKey()).get(jPerWC.getKey()).get(jPerC.getKey()).get(j.sourceAreaID).get(j.tourist.currentTouristType.ID).get(j.tourist.age).put(j.tourist.sex, e);
									}
									else{
										Integer[] e = {1,0};
										dests.getValue().touristsPerTimeSourceAndCat.get(jPerYWC.getKey()).get(jPerWC.getKey()).get(jPerC.getKey()).get(j.sourceAreaID).get(j.tourist.currentTouristType.ID).get(j.tourist.age).put(j.tourist.sex, e);
									}
										//dests.getValue().touristsPerTimeSourceAndCat.get(jPerYWC.getKey()).get(jPerWC.getKey()).put(jPerC.getKey(), touristsPerCat);
								}
								else{
									Integer[] x = dests.getValue().touristsPerTimeSourceAndCat.get(jPerYWC.getKey()).get(jPerWC.getKey()).get(jPerC.getKey()).get(j.sourceAreaID).get(j.tourist.currentTouristType.ID).get(j.tourist.age).get(j.tourist.sex);
									if(j.weeks.get(year).get(0)==week){
										x[0]++;
										x[1]++;
									}
									else{
										x[0]++;
									}
									dests.getValue().touristsPerTimeSourceAndCat.get(jPerYWC.getKey()).get(jPerWC.getKey()).get(jPerC.getKey()).get(j.sourceAreaID).get(j.tourist.currentTouristType.ID).get(j.tourist.age).put(j.tourist.sex, x);
								}
							}
						}
					}
				}
				dests.getValue().bookingJourneys = new HashMap<Integer, HashMap<Integer,HashMap<Integer,Vector<Journey>>>>();
			}
		}
	}
	
	/**
	 * This methods checks the current bookings for crowded destinations and causes redicisions.
	 */
	/*
	private void redecideProcess(){
		if(destinations !=null && booked){
			for(Entry<Integer, DATA_Destination> dests:destinations.entrySet()){
				if(dests.getValue().bedCapacities !=null){
					for(Entry<Integer, HashMap<Integer, HashMap<Integer, Vector<Journey>>>> jPerYWC:dests.getValue().bookingJourneys.entrySet()){
						for(Entry<Integer, HashMap<Integer, Vector<Journey>>> jPerWC: jPerYWC.getValue().entrySet()){
							for(Entry<Integer, Vector<Journey>> jPerC:jPerWC.getValue().entrySet()){
								boolean notIn = false;
								if(dests.getValue().touristsPerTimeSourceAndCat.containsKey(jPerYWC.getKey())){
									if(dests.getValue().touristsPerTimeSourceAndCat.get(jPerYWC.getKey()).containsKey(jPerWC.getKey())){
										if(dests.getValue().touristsPerTimeSourceAndCat.get(jPerYWC.getKey()).get(jPerWC.getKey()).containsKey(jPerC.getKey())){
											int quantity = 0;
											for(Entry<Integer, Integer> i:dests.getValue().touristsPerTimeSourceAndCat.get(jPerYWC.getKey()).get(jPerWC.getKey()).get(jPerC.getKey()).entrySet()){
												quantity += i.getValue();
											}
											int tooMany = (jPerC.getValue().size() + quantity) -dests.getValue().bedCapacities[jPerWC.getKey()][jPerC.getKey()];
											
											if(tooMany>0){
												redecide(jPerC.getValue(), tooMany);
												tooMany = 0;
											}
											
											HashMap<Integer, HashMap<Integer, HashMap<Integer, Integer>>> freeBedsPerYWC = new HashMap<Integer, HashMap<Integer,HashMap<Integer,Integer>>>();
											HashMap<Integer, HashMap<Integer, Integer>> freeBedsPerWC = new HashMap<Integer, HashMap<Integer,Integer>>();
											HashMap<Integer, Integer> freebedsPerC = new HashMap<Integer, Integer>();
											freebedsPerC.put(jPerC.getKey(),tooMany*-1);
											freeBedsPerWC.put(jPerWC.getKey(), freebedsPerC);
											freeBedsPerYWC.put(jPerYWC.getKey(), freeBedsPerWC);
											dests.getValue().freeBeds = freeBedsPerYWC;
										}
										else{
											notIn = true;
										}
									}
									else{
										notIn = true;
									}
								}
								else{
									notIn = true;
								}
								if(notIn){
									int tooMany = (jPerC.getValue().size())-dests.getValue().bedCapacities[jPerWC.getKey()][jPerC.getKey()];
									if(tooMany>0){
										redecide(jPerC.getValue(), tooMany);
										tooMany = 0;
									}
									HashMap<Integer, HashMap<Integer, HashMap<Integer, Integer>>> freeBedsPerYWC = new HashMap<Integer, HashMap<Integer,HashMap<Integer,Integer>>>();
									HashMap<Integer, HashMap<Integer, Integer>> freeBedsPerWC = new HashMap<Integer, HashMap<Integer,Integer>>();
									HashMap<Integer, Integer> freebedsPerC = new HashMap<Integer, Integer>();
									freebedsPerC.put(jPerC.getKey(),tooMany*-1);
									freeBedsPerWC.put(jPerWC.getKey(), freebedsPerC);
									freeBedsPerYWC.put(jPerYWC.getKey(), freeBedsPerWC);
									dests.getValue().freeBeds = freeBedsPerYWC;
								}
							}
						}
					}
				}
			}
		}
	}
	*/
	/**
	 * Lets a given number of tourists redecide their journeys.
	 * @param journeys Vector with all current booking jounerys.
	 * @param tooMany Number of redecisions.
	 */
	private void redecide(Vector<Journey> journeys, int tooMany){
		for(int i=0; i<tooMany ; i++){
			redecide = true;
			int random = (int)(Math.random()*(double)journeys.size());
			Journey j = journeys.get(random);
			journeys.remove(random);
			j.tourist.nextJourney = null;
			j.tourist.makeDecision(simulationTime().getYear(), simulationTime().getMonth(), simulationTime().getDay());
		}
	}
	
	/* (non-Javadoc)
	 * @see org.glowa.danube.deepactors.model.AbstractActorModel#commit()
	 */
	public void commit()
	{
//		System.out.println("TouristProvide");
		writeData();
		
	}	
	
	
	private void writeData(){
		if(destinations !=null && printedWeek!=currentDate.get(GregorianCalendar.WEEK_OF_YEAR)){
			printedWeek=currentDate.get(GregorianCalendar.WEEK_OF_YEAR);
			String query = "";
			boolean realRun = false;

			try{
				if(stmt !=null)stmt.close();
				
				if(con == null){
					Class.forName("com.mysql.jdbc.Driver").newInstance();
				}
				if(con!=null)con.close();
				con = DriverManager.getConnection(database);
				stmt = con.createStatement();
				DatabaseMetaData dbm = (DatabaseMetaData) con.getMetaData();
				
				if (firsttable) {
					firsttable = false;
				//}
					try{
						if(realRun)stmt.executeUpdate("drop table touristsPerDestinations");
					}catch(Exception e){
						//System.out.println("drop fehler"+ touristsPerDestinationTables+simulationTime().getYear()+currentDate.get(GregorianCalendar.WEEK_OF_YEAR));
						//e.printStackTrace();
					}
					try{ //String query="Create table "+touristsPerDestinationTables+simulationTime().getYear()+currentDate.get(GregorianCalendar.WEEK_OF_YEAR)+" (DestID varchar(255), Category varchar(255), SourceID varchar(255), TouristType varchar(255), age varchar(255), sex varchar(255), quantity int(200))";
					
						if(realRun){
							query="Create table touristsPerDestinations (Year integer, Week tinyint, DestID varchar(8), Category tinyint(3), SourceID varchar(8), TouristType tinyint(3), age tinyint(4), sex tinyint(1), lifephase smallint(6), quantity smallint(6), arrivals smallint(6))";					//+simulationTime().getYear()+currentDate.get(GregorianCalendar.WEEK_OF_YEAR)+" (DestID varchar(8), Category tinyint(3), SourceID varchar(8), TouristType tinyint(3), age tinyint(4), sex tinyint(1), quantity smallint(6))";
						}
						else{
						
							ResultSet rs = dbm.getTables(null, null, "Runs", null);
							if (rs.next()) {
								// Table exists
								try{				
									query = "SELECT Run FROM Runs ORDER BY Run DESC LIMIT 1;";
									ResultSet sa = stmt.executeQuery(query);
									sa.next();
									number = sa.getInt("Run")+1;
								}
								catch (Exception ex) {
									ex.printStackTrace();
								}
								try{
									query = "INSERT INTO Runs \n"+"VALUES("+number+","+touristscenario+","+Holidays.scenario+","+"'"+climatescenario+"'"+","+"CURRENT_TIMESTAMP"+
									"\n"+")";
									stmt.executeUpdate(query);
								}
								catch (Exception ex) {
									ex.printStackTrace();
								}
							}	
							else {
								// Table does not exist
								try{
									query = "CREATE TABLE Runs ("+ "Run INTEGER, "+ "Touristscenerio INTEGER, "+ "Holidayscenerio INTEGER, "+ "Climatescenerio VARCHAR(8), "+ "Timestamp TIMESTAMP)";
									stmt.executeUpdate(query);
								} 
								catch (Exception ex) 
								{
									ex.printStackTrace();
								}
								try {
									String insert = "INSERT INTO Runs \n"+"VALUES(";
									insert+="1"+","+touristscenario+","+Holidays.scenario+","+"'"+climatescenario+"'"+","+"CURRENT_TIMESTAMP"+
									"\n"+")";
									stmt.executeUpdate(insert);
								} 
								catch (Exception ex) {
									ex.printStackTrace();
								}
							}
							query="Create table touristsPerDestinations"+number+" (Year integer, Week tinyint, DestID varchar(8), Category tinyint(3), SourceID varchar(8), TouristType tinyint(3), age tinyint(4), sex tinyint(1), lifephase smallint(6), quantity smallint(6),arrivals smallint(6))";					//+simulationTime().getYear()+currentDate.get(GregorianCalendar.WEEK_OF_YEAR)+" (DestID varchar(8), Category tinyint(3), SourceID varchar(8), TouristType tinyint(3), age tinyint(4), sex tinyint(1), quantity smallint(6))";
						}
						stmt.executeUpdate(query);
					}
					catch(Exception e){
						System.out.println("create fehler "+query);
					}
				} 
				else {
					for(Entry<Integer, DATA_Destination> dests:destinations.entrySet()){
						try{
							/*Class.forName("com.mysql.jdbc.Driver").newInstance();
							Connection con = DriverManager.getConnection(database);
							Statement stmt = con.createStatement();*/
							HashMap<Integer, HashMap<Integer,HashMap<Integer, HashMap<Integer, HashMap<Integer,  Integer[]>>>>> touristsPerCatAndSourceHashMap = dests.getValue().touristsPerTimeSourceAndCat.get(currentDate.get(GregorianCalendar.YEAR)).get(currentDate.get(GregorianCalendar.WEEK_OF_YEAR));
							try{	
								for(Entry<Integer, HashMap<Integer, HashMap<Integer, HashMap<Integer, HashMap<Integer, Integer[]>>>>> touristsPerCatAndSource:touristsPerCatAndSourceHashMap.entrySet()){
									try{
										for(Entry<Integer,HashMap<Integer, HashMap<Integer, HashMap<Integer,  Integer[]>>>> touristsPerSource : touristsPerCatAndSource.getValue().entrySet()){
											try{
												for(Entry<Integer,HashMap<Integer, HashMap<Integer,  Integer[]>>> touristsPerType : touristsPerSource.getValue().entrySet()){
													try{
														//Alter in Klassen durchlaufen
														for(Entry<Integer,HashMap<Integer,  Integer[]>> touristsPerAge : touristsPerType.getValue().entrySet()){
															
																//Geschlechter zusammenfassen, wenn keine echte Unterscheidung vorhanden ist.
															query = "";
															for(Entry<Integer, Integer[]> touristsPerSex : touristsPerAge.getValue().entrySet()){
																try{
																	//System.out.println("Year: "+currentDate.get(GregorianCalendar.YEAR) +" Week: "+currentDate.get(GregorianCalendar.WEEK_OF_YEAR)+" Destination: "+dests.getKey()+" in category: "+touristsPerCatAndSource.getKey()+" from SourceArea: "+touristsPerSource.getKey()+" Quantity: "+touristsPerSource.getValue());
																	//String query ="insert into "+touristsPerDestinationTables+simulationTime().getYear()+currentDate.get(GregorianCalendar.WEEK_OF_YEAR)+" values('"+dests.getKey()+"','"+touristsPerCatAndSource.getKey()+"','"+touristsPerSource.getKey()+"','"+touristsPerType.getKey()+"','"+touristsPerAge.getKey()+"','"+touristsPerSex.getKey()+"',"+touristsPerSex.getValue()+")";
																	if(realRun){
																		query ="insert into touristsPerDestinations values('"+simulationTime().getYear()+"','"+currentDate.get(GregorianCalendar.WEEK_OF_YEAR)+"','"+dests.getKey()+"','"+touristsPerCatAndSource.getKey()+"','"+touristsPerSource.getKey()+"','"+touristsPerType.getKey()+"','"+touristsPerAge.getKey()+"','"+touristsPerSex.getKey()+"','"+touristsPerType.getKey()+"',"+touristsPerSex.getValue()[0]+","+touristsPerSex.getValue()[1]+")";
																	}
																	else{
																		query ="insert into touristsPerDestinations"+number+" values('"+simulationTime().getYear()+"','"+currentDate.get(GregorianCalendar.WEEK_OF_YEAR)+"','"+dests.getKey()+"','"+touristsPerCatAndSource.getKey()+"','"+touristsPerSource.getKey()+"','"+touristsPerType.getKey()+"','"+touristsPerAge.getKey()+"','"+touristsPerSex.getKey()+"','"+touristsPerType.getKey()+"',"+touristsPerSex.getValue()[0]+","+touristsPerSex.getValue()[1]+")";
																	}
																	if(debug)System.out.println(query);
																	stmt.executeUpdate(query);
																	query = null;
																}
																catch(Exception e ){
																	System.out.println(query);
																	e.printStackTrace();
																}
															}
														}
													}
													catch(Exception e ){
														e.printStackTrace();
													}
												}
											}
											catch(Exception e ){
												e.printStackTrace();
											}
										
										}
									}
									catch(Exception e ){
										e.printStackTrace();
									}
								}
							}catch(Exception e ){
								
							}
							//con.close();#
						}
						catch(Exception e){	
						}
					}
					con.close();
				}
			}
			catch(Exception e){}
		}
		if(booked && destinations !=null){
//			touristPerDest = new HashMap<Integer, HashMap<Integer,HashMap<Integer,HashMap<Integer,HashMap<Integer,Integer>>>>>();
			touristPerDest = new HashMap<Integer, HashMap<Integer,HashMap<Integer,HashMap<Integer,HashMap<Integer,HashMap<Integer,HashMap<Integer,HashMap<Integer,Integer[]>>>>>>>>();
			for(Entry<Integer, DATA_Destination> dests:destinations.entrySet()){
				touristPerDest.put(dests.getKey(), dests.getValue().touristsPerTimeSourceAndCat);
			}	
		}		
	}
	
	
	/**
	 * Inits the scenario: Societal scenario and Actions will be initialized.
	 */
	private void initScenario()
	{
		
	}
	@Override
	public HashMap<Integer, HashMap<Integer, HashMap<Integer, HashMap<Integer, HashMap<Integer, HashMap<Integer, HashMap<Integer, HashMap<Integer, Integer[]>>>>>>>> getNumberOfTourists() {
		// TODO Auto-generated method stub
		//return numberOfTourists;
		return touristPerDest;
	}

	@Override
	public int getTouristModelScenario() {
		// TODO Auto-generated method stub
		return touristscenario;
	}

	@Override
	public int getHolidayScenario() {
		// TODO Auto-generated method stub
		return Holidays.scenario;
	}
	  
}
