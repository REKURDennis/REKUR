/*
 *  Project: Glowa, IAWG 2002-2003,
 *  $Id: FormatedFileReaderWS.java,v 1.3 2003/05/26 10:17:15 georg Exp $
 */


package org.glowa.danube.components.actor.tourism.utilities;

import java.io.*;


/**
 * Read and parse a ASCII-File.<p>
 * This class provides functions
 * to read integer, float, double and strings values.
 * The FormatedFileReader uses internal a fast buffering schema and
 * a java.io.FileInputStream for reading the file.<p>
 * The FormatedFileReader does NOT extend the FileInputStream
 * since the local buffering schema may break some
 * member functions of the FileInputStream.
 * <p>
 * All Exceptions generated by the FileInputStream are passed
 * forward by the FormatedFileReader.
 *
 * @version 1.0  16.09.2002
 * @author Roland Barthel
 */
// more or less a copy of Rivernet utilities by Georg Kaspar ; see also  <a href="http://www.iawg.de">http://www.iawg.de</a>

public class FormatedFileReaderWS
{

    /**
     * FormatedFileReader constructor.
     * The constructor needs the filename of a file, which will be opend as an argument.
     * The file must exist.
     * @param file - the name of a existing file.
     */
    public FormatedFileReaderWS( String file ) throws FileNotFoundException, IOException
    {
        fis = new FileInputStream( file );

        FileName = file;

        Buf      = new byte[ BufMaxSize ];
        BufTop   = 0;
        BufIdx   = 0;
    }


    /**
     *  get the name of the file, which is connected to this file input stream.
     *  @return the name of the file as a string.
     */
    public String   getFilename()
    {
        return FileName;
    }


    /**
     * check if the end of file is reached.
     * Warning: EOF is signaled after the first EOF-Exception occured.
     * @return true if EOF is reached else false.
     */
    public boolean eofReached()
    {
        return  BufTop == -1;
    }


    /**
     * skips n characters of the input stream.
     * @return the number of chars actually skipped.
     */
    public long  skip( long n ) throws IOException
    {
        long cnt = 0;

        while( ! eofReached() &&  n -- > 0 )
        {
            getChar();
            cnt ++;
        }

        return cnt;
    }


    /**
     * read the next word in the file. A word is a sequence of <i> none</i> white space chars.
     * A Blank, tab, carrage return and the newline char is considered as a white space char.
     * leading white spache chars are skiped.
     * @return a String containing the word.
     */
    public String   readWord()  throws IOException
    {
        char    ch;
        String  Word;

        Word = "";

        do
        {
            ch = getChar();

        } while( ch == '\t' || ch == ' ' || ch == '\n' || ch == '\r' );

        do
        {
            Word += ch;
            ch = getChar();
        } while( ch != '\t' && ch != ' ' && ch != '\n' && ch != '\r');

        return Word;
    }   // end readWord()



    /**
     * read an integer value. A sequence of digits which is seperated
     * by white space is expected.
     * Leading white space is skipped. A NumberFormat Exception is thrown
     * if no integer is found.
     * @return integer value found in the file.
     */
    public int  readInt() throws NumberFormatException, IOException, EOFException
    {
        return Integer.parseInt( readWord() );
    }


    /**
     * read a double value. A valid double number which is seperated
     * by white space is expected.
     * Leading white space is skipped. A NumberFormat Exception is thrown
     * if no double is found.
     * @return double value found in the file.
     */
    public double   readDouble() throws NumberFormatException, IOException
    {
        return Double.parseDouble( readWord() );
    }


    /**
     * read a float value. A valid float number which is seperated
     * by white space is expected.
     * Leading white space is skipped. A NumberFormat Exception is thrown
     * if no float is found.
     * @return float value found in the file.
     */
    public float    readFloat()  throws NumberFormatException, IOException
    {
        return Float.parseFloat( readWord() );
    }


    /**
     * read a whole line of the file. The line ends at the next
     * linefeed found in the file.
     * @return the line as a string value
     */
    public String readLine() throws IOException
    {
        String  line = "";
        char    ch;

        while( (ch = getChar()) != '\n'  && ! eofReached() )
            line = line + ch;

        return line;
    }


    /**
     * skips all chars in the file until a linefeed is found.
     */
    public void killRestOfLine() throws IOException
    {
        while( ! eofReached() &&  getChar() != '\n' )
            ;
    }

    /**
     *  close the file.
     */
    public void close()
    {
        try
        {
            if( fis != null )
                fis.close();
            fis = null;
        }
        catch( Exception e )
        { }
    }


    /**
     * main method allows us to run as a standalone demo.
     * A text file called "text.txt.in" is written and then read.
     */
    public static void main( String argv[] ) // simple Test
    {
        String fname = "text.txt.in";
        String l    = "I am just a single line.";
        String w    = "generated:del.me.now";
        int i       = 10;
        double  d   = 1234.4321;
        float f     = 123.321f;

        try
        {
            FormatedFilePrinterWS ffp = new FormatedFilePrinterWS( fname );
            ffp.print( fname + " " );
            ffp.print( i ); ffp.print( " " );
            ffp.print( d, 10,3 ); ffp.print( " " );
            ffp.print( f ); ffp.print( " " );
            ffp.println( l );

            ffp.println( w );
            ffp.println( l );
            ffp.println( w );

            ffp.print( -10.33333, 6, 2); ffp.println("<");
            ffp.print( -10.33333, 6, 4); ffp.println("<");
            ffp.print( -10.33333, 10, 2); ffp.println("<");
            ffp.print( -10.33333, 20, 2); ffp.println("<");
            ffp.print( -10.33333, -20, 2); ffp.println("<");

            ffp.close();

            FormatedFileReaderWS ffr = new FormatedFileReaderWS( fname );

            w = ffr.readWord();
            i = ffr.readInt();
            d = ffr.readDouble();
            f = ffr.readFloat();
            l = ffr.readLine();

            System.out.println( "w=<" + w + ">  i=" + i + " d ="+ d + "  f=" + f );
            System.out.println( "l=<" + l + ">" );

            l = ffr.readLine();
            System.out.println( "l=<" + l + ">" );

            l = ffr.readLine();
            l = ffr.readLine();
            System.out.println( "l=<" + l + ">" );
        }
        catch ( Exception e )
        {
            System.out.println( "Opps (FormatedFileReader): " + e) ;
            e.printStackTrace();
        }
    }


    /**
     * get one char of the file. This function is the only function that actually
     * reads the file.
     * The file is read in large chunks which are internally buffered
     * to get a better I/O performance. if EOF is reached a EOFException is thrown.
     * @return the next char in the file.
     */
    private final char getChar() throws EOFException, IOException
    {
        char ch = '\0';

        if( BufIdx < BufTop )
            ch = (char)Buf[ BufIdx ++ ];
        else
        {
            BufTop  = fis.read( Buf, 0, BufMaxSize );
            BufIdx  = 1;
            ch      = (char) Buf[ 0 ];
            if( BufTop == -1 )
                throw new EOFException( "FormatedFileReader: EOF reached for file: " + getFilename() );
        }

        return ch;
    }

    //
    // Attributs:
    //

    private final int       BufMaxSize  =  4096;

    private FileInputStream fis;
    private String          FileName;

    private byte            Buf[];
    private int             BufTop, BufIdx;

}   // end class FormatedFileReader

// eof
